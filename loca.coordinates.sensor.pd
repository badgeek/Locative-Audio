#N canvas 57 121 946 866 10;
#X obj 299 392 outlet;
#X obj 36 121 receive fromSystem;
#X obj 36 624 send toGUI;
#X obj 36 174 route /location /compass;
#X msg 106 202 list /displayLabel5 compass heading: \$1 deg.;
#X obj 36 148 list trim;
#X obj 554 182 receive fromGUI;
#X obj 554 269 send toSystem;
#X msg 554 247 list /enableLocation \$1;
#X obj 554 204 list trim;
#X obj 299 370 pack f f;
#X msg 489 608 list /setDistanceFilter \$1;
#X msg 518 638 list /getDistanceFilter;
#X obj 489 672 send toSystem;
#X obj 713 575 receive fromSystem;
#X obj 713 599 route list;
#X obj 713 624 route /distanceFilter;
#X text 483 501 you can get and set the "distance filter" value \,
which specifies how many meters to move before triggering the callback
(and sending messages into PD). Default is 1 Value of <=0 sets it to
"none" and all GPS updates trigger callback.;
#X floatatom 489 582 5 0 0 0 - - -, f 5;
#X floatatom 713 647 5 0 0 0 - - -, f 5;
#X text 34 -134 NOTE: nothing works when this patch is open on your
desktop/laptop...GPS data is only received when running on the device.
;
#X obj 554 225 route /gpsToggle;
#X text 28 -48 when location data is enabled \, it is sent via a message
"/location" with 9 numbers. Location coordinate data in iOS is a 64-bit
floating point number (double) \; PureData is only 32-bit float \,
so sending that number into a patch loses resolution. However \, a
tweaky workaround (via 64-bit math in the iOS layer) is provided by
the last 4 numbers in the message.;
#X text 422 -132 arg 0: latitude coordinate (as 32-bit float);
#X text 422 -114 arg 1: longitude coordinate (as 32-bit float);
#X text 422 -79 arg 3: horizontal accuracy (meters radius);
#X text 423 -96 arg 2: altitude (meters);
#X text 424 -59 arg 4: vertical (altitude) accuracy (meters radius)
;
#X text 423 -39 arg 5: latitude "rough" = 64-bit value multiplied by
1000 and truncated to an integer before being sent into Pd;
#X text 425 14 arg 7: latitude "fine" = 64-bit value modded by 0.001
\, multiplied by 1e+06 \, and truncated to an integer \, before being
sent into Pd So the "rough" contains the significant digits up to the
thousandths place \, and the "fine" contains the next three significant
digits. An original coordinate value of 123.457 would be turned into
rough=123456 fine=789., f 64;
#X text 426 -7 arg 6: longitude "rough" (as above);
#X msg 71 423 list /displayLabel2 altitude: \$1 m;
#X msg 36 369 list /displayLabel6 32-bit lat: \$1;
#X obj 36 255 unpack f f f f f f f f f;
#X text 425 103 arg 8: longitude "fine" (as above);
#X msg 53 397 list /displayLabel7 32-bit lon: \$1;
#X msg 124 502 list /displayLabel0 lat rough: \$1;
#X msg 140 531 list /displayLabel1 lon rough: \$1;
#X msg 159 558 list /displayLabel8 lat fine: \$1;
#X msg 177 585 list /displayLabel9 lon fine: \$1;
#X msg 106 479 list /displayLabel4 alt. accuracy: \$1 m;
#X msg 87 450 list /displayLabel3 position accuracy: \$1 m;
#X obj 299 342 / 1000;
#X obj 347 342 / 1000;
#X connect 1 0 5 0;
#X connect 3 0 33 0;
#X connect 3 1 4 0;
#X connect 4 0 2 0;
#X connect 5 0 3 0;
#X connect 6 0 9 0;
#X connect 8 0 7 0;
#X connect 9 0 21 0;
#X connect 10 0 0 0;
#X connect 11 0 13 0;
#X connect 12 0 13 0;
#X connect 14 0 15 0;
#X connect 15 0 16 0;
#X connect 16 0 19 0;
#X connect 18 0 11 0;
#X connect 21 0 8 0;
#X connect 31 0 2 0;
#X connect 32 0 2 0;
#X connect 33 0 32 0;
#X connect 33 1 35 0;
#X connect 33 2 31 0;
#X connect 33 3 41 0;
#X connect 33 4 40 0;
#X connect 33 5 36 0;
#X connect 33 5 42 0;
#X connect 33 6 37 0;
#X connect 33 6 43 0;
#X connect 33 7 38 0;
#X connect 33 8 39 0;
#X connect 35 0 2 0;
#X connect 36 0 2 0;
#X connect 37 0 2 0;
#X connect 38 0 2 0;
#X connect 39 0 2 0;
#X connect 40 0 2 0;
#X connect 41 0 2 0;
#X connect 42 0 10 0;
#X connect 43 0 10 1;
